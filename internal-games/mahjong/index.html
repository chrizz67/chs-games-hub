<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mahjong</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #game-container {
            text-align: center;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            color: white;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        #game-canvas {
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        #info {
            margin-top: 15px;
            color: white;
            font-size: 18px;
            display: flex;
            justify-content: space-around;
            gap: 20px;
        }
        
        .info-item {
            background: rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
        
        button {
            margin: 10px 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>ðŸ€„ Mahjong Solitaire</h1>
        <canvas id="game-canvas" width="800" height="600"></canvas>
        <div id="info">
            <div class="info-item">Pairs: <span id="pairs">0</span></div>
            <div class="info-item">Remaining: <span id="remaining">144</span></div>
            <div class="info-item">Time: <span id="time">0</span>s</div>
        </div>
        <div>
            <button onclick="newGame()">New Game</button>
            <button onclick="shuffleTiles()">Shuffle</button>
            <button onclick="showHint()">Hint</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        const TILE_WIDTH = 50;
        const TILE_HEIGHT = 65;
        const TILE_DEPTH = 10;
        
        const PATTERNS = ['ðŸ€€','ðŸ€','ðŸ€‚','ðŸ€ƒ','ðŸ€„','ðŸ€…','ðŸ€†','ðŸ€‡','ðŸ€ˆ','ðŸ€‰','ðŸ€Š','ðŸ€‹','ðŸ€Œ','ðŸ€','ðŸ€Ž','ðŸ€','ðŸ€','ðŸ€‘','ðŸ€’','ðŸ€“','ðŸ€”','ðŸ€•','ðŸ€–','ðŸ€—','ðŸ€˜','ðŸ€™','ðŸ€š','ðŸ€›','ðŸ€œ','ðŸ€','ðŸ€ž','ðŸ€Ÿ','ðŸ€ ','ðŸ€¡'];
        
        let tiles = [];
        let selected = null;
        let pairsMatched = 0;
        let startTime = Date.now();
        let timerInterval;
        
        class Tile {
            constructor(x, y, z, pattern) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.pattern = pattern;
                this.matched = false;
            }
            
            isClickable() {
                if (this.matched) return false;
                
                const hasLeft = tiles.some(t => !t.matched && t.z === this.z && t.x === this.x - 1 && Math.abs(t.y - this.y) < 1);
                const hasRight = tiles.some(t => !t.matched && t.z === this.z && t.x === this.x + 1 && Math.abs(t.y - this.y) < 1);
                
                if (hasLeft && hasRight) return false;
                
                const hasAbove = tiles.some(t => !t.matched && t.z === this.z + 1 && 
                    Math.abs(t.x - this.x) < 1 && Math.abs(t.y - this.y) < 1);
                
                return !hasAbove;
            }
            
            draw() {
                if (this.matched) return;
                
                const screenX = 100 + this.x * (TILE_WIDTH * 0.8) - this.z * 5;
                const screenY = 50 + this.y * (TILE_HEIGHT * 0.6) - this.z * 5;
                
                ctx.fillStyle = this.isClickable() ? '#f0f0f0' : '#c0c0c0';
                if (selected === this) {
                    ctx.fillStyle = '#ffd700';
                }
                
                ctx.fillRect(screenX, screenY, TILE_WIDTH, TILE_HEIGHT);
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, TILE_WIDTH, TILE_HEIGHT);
                
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(screenX, screenY, TILE_WIDTH, 5);
                ctx.fillRect(screenX, screenY, 5, TILE_HEIGHT);
                
                ctx.font = '32px Arial';
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.pattern, screenX + TILE_WIDTH / 2, screenY + TILE_HEIGHT / 2);
            }
            
            contains(mouseX, mouseY) {
                const screenX = 100 + this.x * (TILE_WIDTH * 0.8) - this.z * 5;
                const screenY = 50 + this.y * (TILE_HEIGHT * 0.6) - this.z * 5;
                
                return mouseX >= screenX && mouseX <= screenX + TILE_WIDTH &&
                       mouseY >= screenY && mouseY <= screenY + TILE_HEIGHT;
            }
        }
        
        function createTileLayout() {
            tiles = [];
            
            const layout = [
                [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0]
            ];
            
            let tilePatterns = [];
            
            for (let i = 0; i < 72; i++) {
                const pattern = PATTERNS[Math.floor(Math.random() * PATTERNS.length)];
                tilePatterns.push(pattern, pattern);
            }
            
            tilePatterns.sort(() => Math.random() - 0.5);
            
            let index = 0;
            for (let z = 0; z < 4; z++) {
                for (let y = 0; y < layout.length; y++) {
                    for (let x = 0; x < layout[y].length; x++) {
                        if (layout[y][x] === 1 && index < tilePatterns.length) {
                            const tile = new Tile(x, y, z, tilePatterns[index]);
                            tiles.push(tile);
                            index++;
                        }
                    }
                }
            }
            
            tiles.sort((a, b) => {
                if (a.z !== b.z) return a.z - b.z;
                if (a.y !== b.y) return a.y - b.y;
                return a.x - b.x;
            });
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            tiles.forEach(tile => tile.draw());
            
            document.getElementById('remaining').textContent = tiles.filter(t => !t.matched).length;
            document.getElementById('pairs').textContent = pairsMatched;
        }
        
        function handleClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            for (let i = tiles.length - 1; i >= 0; i--) {
                const tile = tiles[i];
                if (tile.matched) continue;
                
                if (tile.contains(x, y) && tile.isClickable()) {
                    if (selected === null) {
                        selected = tile;
                    } else if (selected === tile) {
                        selected = null;
                    } else if (selected.pattern === tile.pattern) {
                        selected.matched = true;
                        tile.matched = true;
                        selected = null;
                        pairsMatched++;
                        
                        if (tiles.every(t => t.matched)) {
                            clearInterval(timerInterval);
                            setTimeout(() => alert('Congratulations! You won!'), 100);
                        }
                    } else {
                        selected = tile;
                    }
                    draw();
                    break;
                }
            }
        }
        
        function newGame() {
            createTileLayout();
            selected = null;
            pairsMatched = 0;
            startTime = Date.now();
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            draw();
        }
        
        function shuffleTiles() {
            const unmatched = tiles.filter(t => !t.matched);
            const patterns = unmatched.map(t => t.pattern);
            patterns.sort(() => Math.random() - 0.5);
            unmatched.forEach((tile, i) => {
                tile.pattern = patterns[i];
            });
            selected = null;
            draw();
        }
        
        function showHint() {
            const clickable = tiles.filter(t => !t.matched && t.isClickable());
            
            for (let i = 0; i < clickable.length; i++) {
                for (let j = i + 1; j < clickable.length; j++) {
                    if (clickable[i].pattern === clickable[j].pattern) {
                        selected = clickable[i];
                        draw();
                        setTimeout(() => {
                            selected = clickable[j];
                            draw();
                            setTimeout(() => {
                                selected = null;
                                draw();
                            }, 500);
                        }, 500);
                        return;
                    }
                }
            }
            
            alert('No available moves! Try shuffling.');
        }
        
        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('time').textContent = elapsed;
        }
        
        canvas.addEventListener('click', handleClick);
        
        newGame();
    </script>
</body>
</html>
